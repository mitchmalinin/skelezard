<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
        background: rgb(48, 48, 48);
      }

      #app {
        width: 50%;
        text-align: center;
        margin-top: 50px;
        display: grid;
      }

      img,
      canvas {
        max-width: 800px;
        height: auto;
        display: block;
        margin: 0 auto;
      }

      #button-container {
        margin-top: 20px;
        display: grid;
        gap: 1rem;
        grid-template-columns: 1fr 1fr;
      }

      button {
        font-size: 16px;
        padding: 10px 20px;
        margin: 0 10px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <img id="source-image" src="./skull.jpeg" alt="Original Image" />
      <div id="button-container">
        <button id="glitch-effect-1">Glitch Effect 1</button>
        <button id="glitch-effect-2">Glitch Effect 2</button>
        <button id="glitch-effect-3">Glitch Effect 3</button>
        <button id="glitch-all">ALL Glitch</button>
        <button id="reset">Reset</button>
      </div>
    </div>
    <script>
      const GLITCH_MAP = {
        glitch1: (imageData) => glitchEffect1(imageData),
        glitch2: (imageData) => glitchEffect2(imageData),
        glitch3: (imageData) => glitchEffect3(imageData),
      }

      const MAX_GLITCH_AMOUNT = 5
      let counter = 0
      let activateGlitchMode = false
      const activateGlitchModeWord = "glitch"
      const activateGlitchModeWordArray = []
      const sourceImage = document.getElementById("source-image")
      const canvas = document.createElement("canvas")
      const ctx = canvas.getContext("2d")

      const glitchEffect1 = (imageData) => {
        const glitchedData = new ImageData(imageData.width, imageData.height)
        const blockSize = Math.floor(Math.random() * 50) + 10
        const flip = Math.random() < 0.5 ? -1 : 1
        for (let y = 0; y < imageData.height; y += blockSize) {
          for (let x = 0; x < imageData.width; x += blockSize) {
            const offsetX =
              flip *
              (Math.floor(Math.random() * blockSize) -
                Math.floor(blockSize / 2))
            const offsetY =
              flip *
              (Math.floor(Math.random() * blockSize) -
                Math.floor(blockSize / 2))
            const sourceX = x + offsetX
            const sourceY = y + offsetY

            for (let i = 0; i < blockSize; i++) {
              for (let j = 0; j < blockSize; j++) {
                const destX = x + j
                const destY = y + i
                const srcX = sourceX + j
                const srcY = sourceY + i

                if (
                  srcX >= 0 &&
                  srcX < imageData.width &&
                  srcY >= 0 &&
                  srcY < imageData.height
                ) {
                  const sourceIndex = (srcY * imageData.width + srcX) * 4
                  const destIndex = (destY * imageData.width + destX) * 4

                  glitchedData.data[destIndex] = imageData.data[sourceIndex]
                  glitchedData.data[destIndex + 1] =
                    imageData.data[sourceIndex + 1]
                  glitchedData.data[destIndex + 2] =
                    imageData.data[sourceIndex + 2]
                  glitchedData.data[destIndex + 3] =
                    imageData.data[sourceIndex + 3]
                }
              }
            }
          }
        }
        return glitchedData
      }

      const glitchEffect2 = (imageData) => {
        const glitchedData = new ImageData(imageData.width, imageData.height)
        const channelShift = Math.floor(Math.random() * 300)

        for (let i = 0; i < imageData.data.length; i += 4) {
          glitchedData.data[i] = imageData.data[i - channelShift] // Red
          glitchedData.data[i + 1] = imageData.data[i + 1 + channelShift] // Green
          glitchedData.data[i + 2] = imageData.data[i + 2 - channelShift] // Blue
          glitchedData.data[i + 3] = imageData.data[i + 3 + channelShift] // Alpha
        }
        return glitchedData
      }

      const glitchEffect3 = (imageData) => {
        const glitchedData = new ImageData(imageData.width, imageData.height)
        const noiseIntensity = Math.floor(Math.random() * 50)
        const applyNoise = [
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5,
        ]

        for (let i = 0; i < imageData.data.length; i += 4) {
          const noise =
            Math.floor(Math.random() * (noiseIntensity * 2)) - noiseIntensity

          glitchedData.data[i] = applyNoise[0]
            ? Math.max(0, Math.min(255, imageData.data[i] + noise))
            : imageData.data[i] // Red
          glitchedData.data[i + 1] = applyNoise[1]
            ? Math.max(0, Math.min(255, imageData.data[i + 1] + noise))
            : imageData.data[i + 1] // Green
          glitchedData.data[i + 2] = applyNoise[2]
            ? Math.max(0, Math.min(255, imageData.data[i + 2] + noise))
            : imageData.data[i + 2] // Blue
          glitchedData.data[i + 3] = imageData.data[i + 3] // Alpha
        }
        return glitchedData
      }

      const applyGlitchEffects = (imageData, effects) => {
        let glitchedData = imageData
        for (const effect of effects) {
          glitchedData = GLITCH_MAP[effect](glitchedData)
        }
        return glitchedData
      }

      const applyAllGlitchEffects = (imageData) => {
        if (counter < MAX_GLITCH_AMOUNT) {
          counter++
          return applyGlitchEffects(imageData, [
            "glitch1",
            "glitch2",
            "glitch3",
          ])
        } else {
          return imageData
        }
      }

      const createGlitchButtonListener = (glitchEffect) => () => {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
        const glitchedData = glitchEffect(imageData)
        ctx.putImageData(glitchedData, 0, 0)
      }

      const debounce = (fn, delay) => {
        let timeout
        return (...args) => {
          clearTimeout(timeout)
          timeout = setTimeout(() => {
            fn(...args)
          }, delay)
        }
      }

      const handleKeyPress = (event) => {
        if (event.code === "Escape" && activateGlitchMode) {
          activateGlitchModeWordArray.length = 0
          activateGlitchMode = false
        }
        if (
          (event.code === "Backspace" || event.code === "Delete") &&
          activateGlitchMode
        ) {
          counter = 0
          ctx.drawImage(sourceImage, 0, 0)
        }

        if (
          activateGlitchModeWordArray.length < activateGlitchModeWord.length
        ) {
          switch (event.code) {
            case "KeyG":
              activateGlitchModeWordArray.push("g")
              break
            case "KeyL":
              activateGlitchModeWordArray.push("l")
              break
            case "KeyI":
              activateGlitchModeWordArray.push("i")
              break
            case "KeyT":
              activateGlitchModeWordArray.push("t")
              break
            case "KeyC":
              activateGlitchModeWordArray.push("c")
              break
            case "KeyH":
              activateGlitchModeWordArray.push("h")
              break
          }
        } else {
          if (activateGlitchModeWordArray.join("") === activateGlitchModeWord) {
            if (!activateGlitchMode) {
              const imageData = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              )
              const glitchedData = applyAllGlitchEffects(imageData)
              ctx.putImageData(glitchedData, 0, 0)
            }
            activateGlitchMode = true
          } else {
            activateGlitchModeWordArray.length = 0
          }
        }
      }

      const reset = () => {
        counter = 0
        ctx.drawImage(sourceImage, 0, 0)
      }

      document
        .getElementById("glitch-effect-1")
        .addEventListener("click", createGlitchButtonListener(glitchEffect1))
      document
        .getElementById("glitch-effect-2")
        .addEventListener("click", createGlitchButtonListener(glitchEffect2))
      document
        .getElementById("glitch-effect-3")
        .addEventListener("click", createGlitchButtonListener(glitchEffect3))
      document
        .getElementById("glitch-all")
        .addEventListener(
          "click",
          debounce(createGlitchButtonListener(applyAllGlitchEffects), 400)
        )

      document.addEventListener("keydown", handleKeyPress)

      document.getElementById("reset").addEventListener("click", reset)

      sourceImage.addEventListener("load", () => {
        canvas.width = 1024
        canvas.height = 1024
        ctx.drawImage(sourceImage, 0, 0)
        sourceImage.parentNode.replaceChild(canvas, sourceImage)
      })
    </script>
  </body>
</html>
