<!DOCTYPE html>
<!-- 
                                 ,---.
                                /    |
                               /     |
                              /      |
                             /       |
                        ___,'        |
                      <  -'          :
                       `-.__..--'``-,_\_
                          |o/ <o>` :,.)_`>
                          :/ `     ||/)
                          (_.).__,-` |\
                          /( `.``   `| :
                          \'`-.)  `  ; ;
                          | `       /-<
                          |     `  /   `.
          ,-_-..____     /|  `    :__..-'\
         /,'-.__\\  ``-./ :`      ;       \
         `\ `\  `\\  \ :  (   `  /  ,   `. \
           \` \   \\   |  | `   :  :     .\ \
            \ `\_  ))  :  ;     |  |      ): :
           (`-.-'\ ||  |\ \   ` ;  ;       | |
            \-_   `;;._   ( `  /  /_       | |
             `-.-.// ,'`-._\__/_,'         ; |
                \:: :     /     `     ,   /  |
                 || |    (        ,' /   /   |
                 ||                ,'   / SSt|

███╗░░░███╗██████╗░░░░░██╗░░░░░░░██╗███████╗██████╗░██████╗░
████╗░████║██╔══██╗░░░░██║░░██╗░░██║╚════██║██╔══██╗██╔══██╗
██╔████╔██║██████╔╝░░░░╚██╗████╗██╔╝░░███╔═╝██████╔╝██║░░██║
██║╚██╔╝██║██╔══██╗░░░░░████╔═████║░██╔══╝░░██╔══██╗██║░░██║
██║░╚═╝░██║██║░░██║██╗░░╚██╔╝░╚██╔╝░███████╗██║░░██║██████╔╝
╚═╝░░░░░╚═╝╚═╝░░╚═╝╚═╝░░░╚═╝░░░╚═╝░░╚══════╝╚═╝░░╚═╝╚═════╝░

 -->

<html>
  <head>
    <style>
      body {
        background: rgb(48, 48, 48);
      }

      #app {
        width: 50%;
        text-align: center;
        margin-top: 50px;
        display: grid;
      }

      img,
      canvas {
        max-width: 800px;
        height: auto;
        display: block;
        margin: 0 auto;
      }

      #button-container {
        margin-top: 20px;
        display: grid;
        gap: 1rem;
        grid-template-columns: 1fr 1fr;
      }

      button {
        font-size: 16px;
        padding: 10px 20px;
        margin: 0 10px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <img id="source-image" src="./skull.jpg" alt="Original Image" />
    </div>
    <script>
      const GLITCH_MAP = {
        glitch1: (imageData) => glitchEffect1(imageData),
        glitch2: (imageData) => glitchEffect2(imageData),
        glitch3: (imageData) => glitchEffect3(imageData),
      }

      const MAX_GLITCH_AMOUNT = 5
      let counter = 0
      let activateGlitchMode = false
      const activateGlitchModeWord = "glitch"
      const activateGlitchModeWordArray = []
      const sourceImage = document.getElementById("source-image")
      const canvas = document.createElement("canvas")
      const ctx = canvas.getContext("2d")

      const glitchEffect1 = (imageData) => {
        const glitchedData = new ImageData(imageData.width, imageData.height)
        const blockSize = Math.floor(Math.random() * 50) + 10
        const flip = Math.random() < 0.5 ? -1 : 1
        for (let y = 0; y < imageData.height; y += blockSize) {
          for (let x = 0; x < imageData.width; x += blockSize) {
            const offsetX =
              flip *
              (Math.floor(Math.random() * blockSize) -
                Math.floor(blockSize / 2))
            const offsetY =
              flip *
              (Math.floor(Math.random() * blockSize) -
                Math.floor(blockSize / 2))
            const sourceX = x + offsetX
            const sourceY = y + offsetY

            for (let i = 0; i < blockSize; i++) {
              for (let j = 0; j < blockSize; j++) {
                const destX = x + j
                const destY = y + i
                const srcX = sourceX + j
                const srcY = sourceY + i

                if (
                  srcX >= 0 &&
                  srcX < imageData.width &&
                  srcY >= 0 &&
                  srcY < imageData.height
                ) {
                  const sourceIndex = (srcY * imageData.width + srcX) * 4
                  const destIndex = (destY * imageData.width + destX) * 4

                  glitchedData.data[destIndex] = imageData.data[sourceIndex]
                  glitchedData.data[destIndex + 1] =
                    imageData.data[sourceIndex + 1]
                  glitchedData.data[destIndex + 2] =
                    imageData.data[sourceIndex + 2]
                  glitchedData.data[destIndex + 3] =
                    imageData.data[sourceIndex + 3]
                }
              }
            }
          }
        }
        return glitchedData
      }

      const glitchEffect2 = (imageData) => {
        const glitchedData = new ImageData(imageData.width, imageData.height)
        const channelShift = Math.floor(Math.random() * 300)

        for (let i = 0; i < imageData.data.length; i += 4) {
          glitchedData.data[i] = imageData.data[i - channelShift] // Red
          glitchedData.data[i + 1] = imageData.data[i + 1 + channelShift] // Green
          glitchedData.data[i + 2] = imageData.data[i + 2 - channelShift] // Blue
          glitchedData.data[i + 3] = imageData.data[i + 3 + channelShift] // Alpha
        }
        return glitchedData
      }

      const glitchEffect3 = (imageData) => {
        const glitchedData = new ImageData(imageData.width, imageData.height)
        const noiseIntensity = Math.floor(Math.random() * 50)
        const applyNoise = [
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5,
        ]

        for (let i = 0; i < imageData.data.length; i += 4) {
          const noise =
            Math.floor(Math.random() * (noiseIntensity * 2)) - noiseIntensity

          glitchedData.data[i] = applyNoise[0]
            ? Math.max(0, Math.min(255, imageData.data[i] + noise))
            : imageData.data[i] // Red
          glitchedData.data[i + 1] = applyNoise[1]
            ? Math.max(0, Math.min(255, imageData.data[i + 1] + noise))
            : imageData.data[i + 1] // Green
          glitchedData.data[i + 2] = applyNoise[2]
            ? Math.max(0, Math.min(255, imageData.data[i + 2] + noise))
            : imageData.data[i + 2] // Blue
          glitchedData.data[i + 3] = imageData.data[i + 3] // Alpha
        }
        return glitchedData
      }

      const applyGlitchEffects = (imageData, effects) => {
        let glitchedData = imageData
        for (const effect of effects) {
          glitchedData = GLITCH_MAP[effect](glitchedData)
        }
        return glitchedData
      }

      const applyAllGlitchEffects = (imageData) => {
        if (counter < MAX_GLITCH_AMOUNT) {
          counter++
          return applyGlitchEffects(imageData, [
            "glitch1",
            "glitch2",
            "glitch3",
          ])
        } else {
          return imageData
        }
      }

      const createGlitchImage = (glitchEffect) => {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
        const glitchedData = glitchEffect(imageData)
        ctx.putImageData(glitchedData, 0, 0)
      }

      const handleKeyPress = async (event) => {
        if (event.code === "Space" && activateGlitchMode) {
          createGlitchImage(applyAllGlitchEffects)
        }

        if (event.code === "Escape" && activateGlitchMode) {
          activateGlitchModeWordArray.length = 0
          activateGlitchMode = false
          reset()
        }
        if (
          (event.code === "Backspace" || event.code === "Delete") &&
          activateGlitchMode
        ) {
          counter = 0
          ctx.drawImage(sourceImage, 0, 0)
        }

        if (event.altKey && event.code === "KeyS" && activateGlitchMode) {
          const glitchedImageData = ctx.getImageData(
            0,
            0,
            canvas.width,
            canvas.height
          )

          const dataUrl = canvas.toDataURL("image/webp")

          const base64Image = dataUrl.split(",")[1]

          try {
            const uploadedHash = await (
              await fetch(
                "http://localhost:8888/.netlify/functions/uploadToIPFS",
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                  },
                  body: base64Image,
                }
              )
            ).json()
            console.log(uploadedHash)
          } catch (err) {
            console.log("Whoops something broke")
          }
        }

        if (
          activateGlitchModeWordArray.length < activateGlitchModeWord.length
        ) {
          switch (event.code) {
            case "KeyG":
              activateGlitchModeWordArray.push("g")
              break
            case "KeyL":
              activateGlitchModeWordArray.push("l")
              break
            case "KeyI":
              activateGlitchModeWordArray.push("i")
              break
            case "KeyT":
              activateGlitchModeWordArray.push("t")
              break
            case "KeyC":
              activateGlitchModeWordArray.push("c")
              break
            case "KeyH":
              activateGlitchModeWordArray.push("h")
              break
          }
        } else {
          if (activateGlitchModeWordArray.join("") === activateGlitchModeWord) {
            if (!activateGlitchMode) {
              createGlitchImage(applyAllGlitchEffects)
            }
            activateGlitchMode = true
          } else {
            activateGlitchModeWordArray.length = 0
          }
        }
      }

      const reset = () => {
        counter = 0
        ctx.drawImage(sourceImage, 0, 0)
      }

      async function imageDataToBlob(imageData) {
        const tempCanvas = document.createElement("canvas")
        tempCanvas.width = imageData.width
        tempCanvas.height = imageData.height

        const tempCtx = tempCanvas.getContext("2d")
        tempCtx.putImageData(imageData, 0, 0)

        return new Promise((resolve) => {
          tempCanvas.toBlob((blob) => {
            resolve(blob)
          }, "image/png")
        })
      }

      document.addEventListener("keydown", handleKeyPress)

      sourceImage.addEventListener("load", () => {
        canvas.width = 1024
        canvas.height = 1024
        ctx.drawImage(sourceImage, 0, 0)
        sourceImage.parentNode.replaceChild(canvas, sourceImage)
      })
    </script>
  </body>
</html>
